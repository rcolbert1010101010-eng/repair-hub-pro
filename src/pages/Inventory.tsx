import { useNavigate, useSearchParams } from 'react-router-dom';
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { PageHeader } from '@/components/layout/PageHeader';
import { DataTable, Column } from '@/components/ui/data-table';
import { Button } from '@/components/ui/button';
import { Plus } from 'lucide-react';
import { useRepos } from '@/repos';
import type { Part } from '@/types';
import { cn } from '@/lib/utils';
import { Input } from '@/components/ui/input';
import { useToast } from '@/hooks/use-toast';
import {
  Dialog,
  DialogContent,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Checkbox } from '@/components/ui/checkbox';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { useShopStore } from '@/stores/shopStore';
import { Label } from '@/components/ui/label';

export default function Inventory() {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const repos = useRepos();
  const { parts } = repos.parts;
  const { vendors } = repos.vendors;
  const { categories } = repos.categories;
  const { toast } = useToast();
  const [scanValue, setScanValue] = useState('');
  const scanInputRef = useRef<HTMLInputElement | null>(null);
  const inventoryMovements = useShopStore((s) => s.inventoryMovements);
  const inventoryAdjustments = useShopStore((s) => s.inventoryAdjustments);
  const [adjustDialogOpen, setAdjustDialogOpen] = useState(false);
  const [selectedPart, setSelectedPart] = useState<Part | null>(null);
  const [newQoh, setNewQoh] = useState('');
  const [adjustReason, setAdjustReason] = useState('');
  const closeAdjustDialog = () => {
    setAdjustDialogOpen(false);
    setSelectedPart(null);
    setNewQoh('');
    setAdjustReason('');
  };
  const [stockFilter, setStockFilter] = useState<'ALL' | 'LOW' | 'OUT'>('ALL');
  const [needsReorderOnly, setNeedsReorderOnly] = useState(false);
  const [adjustWarning, setAdjustWarning] = useState<string | null>(null);
  const [adjustError, setAdjustError] = useState<string | null>(null);
  const [cycleCountMode, setCycleCountMode] = useState(false);
  const [selectedIds, setSelectedIds] = useState<Record<string, boolean>>({});
  const [countInputs, setCountInputs] = useState<Record<string, string>>({});
  const [batchReason, setBatchReason] = useState('');
  const [batchSummary, setBatchSummary] = useState<{ updated: number; skipped: number; failed: number } | null>(null);
  const countInputRefs = useRef<Record<string, HTMLInputElement | null>>({});
  const movementSummary = useMemo(() => {
    const cutoff = Date.now() - 30 * 24 * 60 * 60 * 1000;
    const summary: Record<string, { lastCountedAt: string | null; delta30d: number }> = {};
    inventoryMovements.forEach((m) => {
      const current = summary[m.part_id] ?? { lastCountedAt: null, delta30d: 0 };
      if (m.movement_type === 'COUNT' || (m.movement_type === 'ADJUST' && m.reason?.startsWith('COUNT:'))) {
        if (!current.lastCountedAt || new Date(m.performed_at) > new Date(current.lastCountedAt)) {
          current.lastCountedAt = m.performed_at;
        }
      }
      const performedTs = new Date(m.performed_at).getTime();
      if (Number.isFinite(performedTs) && performedTs >= cutoff) {
        let delta = 0;
        if (m.movement_type === 'RECEIVE' || m.movement_type === 'RETURN' || m.movement_type === 'ADJUST') {
          delta = m.qty_delta;
        } else if (m.movement_type === 'ISSUE') {
          delta = -m.qty_delta;
        }
        current.delta30d += delta;
      }
      summary[m.part_id] = current;
    });
    return summary;
  }, [inventoryMovements]);

  const columns: Column<Part>[] = [
    ...(cycleCountMode
      ? [
          {
            key: 'select',
            header: '',
            sortable: false,
            render: (item: Part) => (
              <Checkbox
                checked={!!selectedIds[item.id]}
                onCheckedChange={(checked) =>
                  setSelectedIds((prev) => ({ ...prev, [item.id]: Boolean(checked) }))
                }
                onClick={(e) => e.stopPropagation()}
              />
            ),
            className: 'w-10',
          } as Column<Part>,
        ]
      : []),
    {
      key: 'part_number',
      header: 'Part #',
      sortable: true,
      render: (item) => (
        <div className="flex flex-col gap-1">
          <span className="font-mono font-semibold">{item.part_number}</span>
          <div className="flex flex-wrap gap-2 text-[11px] text-muted-foreground">
            {item.__lastCountedAt && (
              <span className="rounded-md bg-muted px-2 py-0.5">
                Last count {new Date(item.__lastCountedAt).toLocaleDateString()}
              </span>
            )}
            <span className="rounded-md bg-muted px-2 py-0.5">
              30d Δ {item.__delta30d > 0 ? `+${item.__delta30d}` : item.__delta30d}
            </span>
            {item.__needsReorder && Number.isFinite(item.__suggested) && item.__suggested > 0 && (
              <span className="rounded-md bg-muted px-2 py-0.5">
                Suggested {item.__suggested}
              </span>
            )}
          </div>
        </div>
      ),
      className: 'font-mono',
    },
    { key: 'description', header: 'Description', sortable: true },
    {
      key: 'category_id',
      header: 'Category',
      sortable: true,
      render: (item) => {
        const category = categories.find((c) => c.id === item.category_id);
        return category?.category_name || '-';
      },
    },
    {
      key: 'bin_location',
      header: 'Bin',
      sortable: false,
      render: (item) => item.bin_location || '—',
    },
    {
      key: 'vendor_id',
      header: 'Vendor',
      sortable: true,
      render: (item) => {
        const vendor = vendors.find((v) => v.id === item.vendor_id);
        return vendor?.vendor_name || '-';
      },
    },
    {
      key: 'cost',
      header: 'Cost',
      sortable: true,
      render: (item) => `$${item.cost.toFixed(2)}`,
      className: 'text-right',
    },
    {
      key: 'selling_price',
      header: 'Price',
      sortable: true,
      render: (item) => `$${item.selling_price.toFixed(2)}`,
      className: 'text-right',
    },
    {
      key: 'min_qty',
      header: 'Min',
      sortable: false,
      render: (item) => (item.min_qty ?? '—'),
      className: 'text-right',
    },
    {
      key: 'max_qty',
      header: 'Max',
      sortable: false,
      render: (item) => (item.max_qty ?? '—'),
      className: 'text-right',
    },
    {
      key: 'quantity_on_hand',
      header: 'QOH',
      sortable: true,
      render: (item) => (
        <div className="flex items-center gap-2 justify-end">
          <span
            className={cn(
              'font-medium',
              item.quantity_on_hand < 0 && 'text-destructive',
              item.quantity_on_hand === 0 && 'text-warning'
            )}
          >
            {item.quantity_on_hand}
          </span>
          {cycleCountMode && (
            <Input
              type="number"
              placeholder="Counted"
              value={countInputs[item.id] ?? ''}
              onClick={(e) => e.stopPropagation()}
              onChange={(e) => setCountInputs((prev) => ({ ...prev, [item.id]: e.target.value }))}
              onFocus={(e) => e.currentTarget.select()}
              onKeyDown={(e) => handleCountKeyDown(item.id, e)}
              className="h-8 w-24"
              disabled={!selectedIds[item.id]}
              ref={(el) => {
                countInputRefs.current[item.id] = el;
              }}
            />
          )}
        </div>
      ),
      className: 'text-right',
    },
    {
      key: 'reorder',
      header: 'Reorder',
      sortable: false,
      render: (item) => {
        const vendor = vendors.find((v) => v.id === item.vendor_id);
        const lead = (vendor as any)?.lead_time_days; // only if present in data; ignore otherwise
        const target = item.max_qty ?? item.min_qty ?? null;
        const suggested = target != null ? Math.max(0, target - item.quantity_on_hand) : 0;
        return (
          <div className="flex flex-col items-end text-sm">
            <span className={cn('font-semibold', suggested > 0 ? 'text-amber-800' : 'text-muted-foreground')}>
              {target == null ? '—' : suggested}
            </span>
            {lead ? <span className="text-[11px] text-muted-foreground">Lead: {lead}d</span> : null}
          </div>
        );
      },
      className: 'text-right',
    },
    {
      key: 'stock_status',
      header: 'Stock',
      sortable: false,
      render: (item) => {
        const isOut = item.quantity_on_hand === 0;
        const isLow = item.min_qty != null && item.quantity_on_hand < item.min_qty;
        const status = isOut ? 'OUT' : isLow ? 'LOW' : 'OK';
        const badgeClass =
          status === 'OUT'
            ? 'bg-destructive/15 text-destructive'
            : status === 'LOW'
            ? 'bg-amber-100 text-amber-800 border border-amber-300'
            : 'bg-emerald-100 text-emerald-800 border border-emerald-200';
        return (
          <span className={cn('inline-flex items-center rounded-full px-2 py-1 text-xs font-semibold', badgeClass)}>
            {status}
          </span>
        );
      },
      className: 'text-right',
    },
    {
      key: 'actions',
      header: 'Actions',
      className: 'text-right',
      render: (item) =>
        item.is_active ? (
          <Button
            variant="outline"
            size="sm"
            onClick={(e) => {
              e.stopPropagation();
              setSelectedPart(item);
              setNewQoh(item.quantity_on_hand.toString());
              setAdjustReason('');
              setAdjustDialogOpen(true);
            }}
          >
            Adjust QOH
          </Button>
        ) : (
          <span className="text-xs text-muted-foreground">Inactive</span>
        ),
    },
  ];

  const handleScan = useCallback(
    (value: string) => {
      const trimmed = value.trim();
      if (!trimmed) return;
      const matched =
        parts.find((p) => p.barcode && p.barcode === trimmed) ||
        parts.find((p) => p.part_number === trimmed);
      if (matched) {
        navigate(`/inventory/${matched.id}`);
      } else {
        toast({ title: 'Barcode not found', description: 'No matching part for scanned value' });
      }
      setScanValue('');
    },
    [navigate, parts, toast]
  );

  useEffect(() => {
    if (!scanValue) return;
    const timer = setTimeout(() => handleScan(scanValue), 200);
    return () => clearTimeout(timer);
  }, [scanValue, handleScan]);

  const recentMovements = useMemo(() => {
    if (!selectedPart) return [];
    return inventoryMovements
      .filter((m) => m.part_id === selectedPart.id)
      .sort((a, b) => new Date(b.performed_at).getTime() - new Date(a.performed_at).getTime())
      .slice(0, 10);
  }, [inventoryMovements, selectedPart]);

  const recentAdjustments = useMemo(() => {
    if (!selectedPart) return [];
    return inventoryAdjustments
      .filter((a) => a.part_id === selectedPart.id)
      .sort((a, b) => new Date(b.adjusted_at).getTime() - new Date(a.adjusted_at).getTime())
      .slice(0, 10);
  }, [inventoryAdjustments, selectedPart]);

  const enhancedParts = useMemo(() => {
    return parts.map((p) => {
      const isOut = p.quantity_on_hand === 0;
      const isLow = p.min_qty != null && p.quantity_on_hand < p.min_qty;
      const target = p.max_qty ?? p.min_qty ?? null;
      const suggested = target != null ? Math.max(0, target - p.quantity_on_hand) : 0;
      const summary = movementSummary[p.id];
      return {
        ...p,
        __stock: (isOut ? 'OUT' : isLow ? 'LOW' : 'OK') as 'OUT' | 'LOW' | 'OK',
        __target: target,
        __suggested: suggested,
        __needsReorder: suggested > 0 && Number.isFinite(suggested) && suggested > 0,
        __lastCountedAt: summary?.lastCountedAt ?? null,
        __delta30d: summary?.delta30d ?? 0,
      };
    });
  }, [movementSummary, parts]);

  const filteredParts = useMemo(() => {
    let list = enhancedParts;
    const searchQuery = (searchParams.get('search') || '').toLowerCase();
    if (searchQuery) {
      list = list.filter(
        (p) =>
          p.part_number.toLowerCase().includes(searchQuery) ||
          (p.description || '').toLowerCase().includes(searchQuery)
      );
    }
    if (stockFilter !== 'ALL') {
      list = list.filter((p) => p.__stock === stockFilter);
    }
    if (needsReorderOnly) {
      list = list.filter((p) => p.__needsReorder);
    }
    return list;
  }, [enhancedParts, needsReorderOnly, searchParams, stockFilter]);
  const selectedParts = useMemo(
    () => filteredParts.filter((p) => selectedIds[p.id]),
    [filteredParts, selectedIds]
  );
  const invalidCount = useMemo(
    () =>
      selectedParts.filter((p) => {
        const raw = countInputs[p.id];
        const num = Number(raw);
        return raw == null || raw === '' || !Number.isFinite(num) || num < 0;
      }).length,
    [countInputs, selectedParts]
  );
  const validCount = useMemo(
    () =>
      selectedParts.filter((p) => {
        const raw = countInputs[p.id];
        const num = Number(raw);
        return raw != null && raw !== '' && Number.isFinite(num) && num >= 0;
      }).length,
    [countInputs, selectedParts]
  );
  const cycleCountIssues = useMemo(() => {
    const issues: string[] = [];
    if (!batchReason.trim()) issues.push('Reason required to apply counts.');
    if (selectedParts.length === 0) issues.push('Select at least one part.');
    const hasInvalid = selectedParts.some((p) => {
      const raw = countInputs[p.id];
      const num = Number(raw);
      return raw != null && raw !== '' && (!Number.isFinite(num) || num < 0);
    });
    if (hasInvalid) issues.push('Invalid counts present (must be >= 0).');
    const hasAnyEntry = selectedParts.some((p) => {
      const raw = countInputs[p.id];
      return raw != null && raw !== '';
    });
    if (selectedParts.length > 0 && !hasAnyEntry) issues.push('Enter a count for at least one selected part.');
    return issues;
  }, [batchReason, countInputs, selectedParts]);
  const cycleCountBlocker = cycleCountIssues[0] || '';
  const applyDisabled = Boolean(cycleCountBlocker);
  const adjustIssues = useMemo(() => {
    const issues: string[] = [];
    if (!selectedPart) issues.push('Select a part to adjust.');
    if (!adjustReason.trim()) issues.push('Reason required.');
    if (!Number.isFinite(Number(newQoh))) issues.push('Enter a valid quantity.');
    return issues;
  }, [adjustReason, newQoh, selectedPart]);
  const focusNextCountInput = (partId: string, direction: 'forward' | 'backward' = 'forward') => {
    const idx = filteredParts.findIndex((p) => p.id === partId);
    if (idx === -1) return;
    const enforceSelection = selectedParts.length > 0;
    const targetList = enforceSelection
      ? filteredParts.filter((p) => selectedIds[p.id])
      : filteredParts;
    const relativeIdx = targetList.findIndex((p) => p.id === partId);
    if (relativeIdx === -1) return;
    const start = direction === 'forward' ? relativeIdx + 1 : relativeIdx - 1;
    const step = direction === 'forward' ? 1 : -1;
    for (let i = start; i >= 0 && i < targetList.length; i += step) {
      const candidate = targetList[i];
      const ref = countInputRefs.current[candidate.id];
      if (ref && !ref.disabled) {
        ref.focus();
        ref.select?.();
        return;
      }
    }
  };

  const partsById = useMemo(() => new Map(filteredParts.map((p) => [p.id, p])), [filteredParts]);

  const handleCountKeyDown = (partId: string, e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter' || e.key === 'Tab') {
      e.preventDefault();
      focusNextCountInput(partId, e.shiftKey ? 'backward' : 'forward');
      return;
    }
    if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
      e.preventDefault();
      setCountInputs((prev) => {
        const part = partsById.get(partId);
        const baseline = prev[partId] === undefined || prev[partId] === '' ? part?.quantity_on_hand ?? 0 : Number(prev[partId]);
        const current = Number.isFinite(baseline) ? baseline : 0;
        const next =
          e.key === 'ArrowUp' ? current + 1 : Math.max(0, current - 1);
        return { ...prev, [partId]: String(next) };
      });
      return;
    }
    if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'enter') {
      e.preventDefault();
      applyCounts();
      return;
    }
    if (e.key === 'Escape') {
      e.currentTarget.blur();
    }
  };

  const applyCounts = useCallback(() => {
    if (cycleCountBlocker) return;
    const reason = `COUNT: ${batchReason.trim()}`;
    let updated = 0;
    let skipped = 0;
    let failed = 0;
    for (const part of filteredParts) {
      if (!selectedIds[part.id]) continue;
      const raw = countInputs[part.id];
      if (raw == null || raw === '') {
        skipped += 1;
        continue;
      }
      const counted = Number(raw);
      if (!Number.isFinite(counted) || counted < 0) {
        failed += 1;
        continue;
      }
      if (counted === part.quantity_on_hand) {
        skipped += 1;
        continue;
      }
      const result = repos.parts.updatePartWithQohAdjustment(
        part.id,
        { quantity_on_hand: counted },
        { reason, adjusted_by: '' }
      );
      if (result?.error) {
        failed += 1;
      } else {
        updated += 1;
      }
    }
    setBatchSummary({ updated, skipped, failed });
    setSelectedIds({});
    setCountInputs({});
    setBatchReason('');
    toast({
      title: 'Quick cycle count applied',
      description: `Updated ${updated}, Skipped ${skipped}, Failed ${failed}`,
      variant: failed > 0 ? 'destructive' : 'default',
    });
  }, [batchReason, countInputs, cycleCountBlocker, filteredParts, repos.parts, selectedIds, toast]);

  const stockCounts = useMemo(() => {
    let low = 0;
    let out = 0;
    let needs = 0;
    let suggestedTotal = 0;
    let negative = 0;
    enhancedParts.forEach((p) => {
      if (p.quantity_on_hand < 0) negative += 1;
      if (p.__stock === 'OUT') out += 1;
      else if (p.__stock === 'LOW') low += 1;
      if (p.__needsReorder) {
        needs += 1;
        suggestedTotal += p.__suggested;
      }
    });
    return { low, out, needs, suggestedTotal, negative, total: enhancedParts.length };
  }, [enhancedParts]);

  const handleSaveAdjustment = () => {
    if (!selectedPart) return;
    const parsed = Number(newQoh);
    if (!Number.isFinite(parsed)) return;
    if (!adjustReason.trim()) return;
    const result = repos.parts.updatePartWithQohAdjustment(
      selectedPart.id,
      { quantity_on_hand: parsed },
      { reason: adjustReason.trim(), adjusted_by: '' }
    );
    if (result?.error) {
      setAdjustError(result.error);
      toast({ title: 'Adjustment blocked', description: result.error, variant: 'destructive' });
      return;
    }
    if (result?.warning) {
      setAdjustWarning(result.warning);
      toast({ title: 'Inventory adjusted', description: result.warning });
    }
    if (!result?.warning) {
      toast({ title: 'Inventory adjusted' });
    }
    setAdjustWarning(null);
    setAdjustError(null);
    closeAdjustDialog();
  };

  return (
    <div className="page-container">
      <PageHeader
        title="Inventory"
        subtitle="Manage parts and stock levels"
        actions={
          <Button onClick={() => navigate('/inventory/new')}>
            <Plus className="w-4 h-4 mr-2" />
            Add Part
          </Button>
        }
      />

      <div className="flex items-center gap-2 mb-4">
        <Input
          ref={scanInputRef}
          placeholder="Scan barcode"
          value={scanValue}
          onChange={(e) => setScanValue(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              handleScan(scanValue);
            }
          }}
          className="max-w-xs"
        />
        <Button variant="outline" size="sm" onClick={() => scanInputRef.current?.focus()}>
          Focus Scan
        </Button>
        <Button
          variant={cycleCountMode ? 'default' : 'outline'}
          size="sm"
          onClick={() => {
            setCycleCountMode((prev) => !prev);
            setSelectedIds({});
            setCountInputs({});
            setBatchReason('');
            setBatchSummary(null);
          }}
        >
          {cycleCountMode ? 'Exit Quick Cycle Count' : 'Quick Cycle Count'}
        </Button>
      </div>

      <div className="mb-4 flex flex-wrap items-center gap-3">
        <div className="flex flex-wrap items-center gap-2 text-sm">
          <span className="font-semibold">Inventory:</span>
          <span className="rounded-md bg-muted px-2 py-1 text-xs">SKUs {stockCounts.total}</span>
          <span className="rounded-md bg-muted px-2 py-1 text-xs">Low {stockCounts.low}</span>
          <span className="rounded-md bg-muted px-2 py-1 text-xs">Out {stockCounts.out}</span>
          <span className="rounded-md bg-muted px-2 py-1 text-xs">Negative {stockCounts.negative}</span>
        </div>
        <div className="flex items-center gap-2 text-sm">
          <span className="font-semibold">Inventory Alerts:</span>
          <Button
            variant={stockFilter === 'LOW' ? 'default' : 'outline'}
            size="sm"
            onClick={() => setStockFilter('LOW')}
          >
            Low: {stockCounts.low}
          </Button>
          <Button
            variant={stockFilter === 'OUT' ? 'default' : 'outline'}
            size="sm"
            onClick={() => setStockFilter('OUT')}
          >
            Out: {stockCounts.out}
          </Button>
          <Button
            variant={stockFilter === 'ALL' && !needsReorderOnly ? 'default' : 'outline'}
            size="sm"
            onClick={() => {
              setStockFilter('ALL');
              setNeedsReorderOnly(false);
            }}
          >
            All
          </Button>
        </div>
        <div className="flex items-center gap-2 text-sm">
          <span className="font-semibold">Reorder:</span>
          <Button
            variant={needsReorderOnly ? 'default' : 'outline'}
            size="sm"
            onClick={() => setNeedsReorderOnly((prev) => !prev)}
          >
            Needs Reorder: {stockCounts.needs}
          </Button>
          <span className="text-xs text-muted-foreground">
            Suggested units: {stockCounts.suggestedTotal}
          </span>
        </div>
      </div>

      <DataTable
        data={filteredParts}
        columns={columns}
        searchKeys={['part_number', 'description']}
        searchPlaceholder="Search parts..."
        onRowClick={(part, event) => {
          if (cycleCountMode) {
            event?.stopPropagation();
            event?.preventDefault();
            return;
          }
          navigate(`/inventory/${part.id}`);
        }}
        rowClassName={cycleCountMode ? 'cursor-default' : undefined}
        emptyMessage="No parts found. Add your first part to get started."
      />

      {cycleCountMode && (
        <div className="mt-4 border rounded-lg p-4 space-y-3">
          <div className="flex flex-wrap items-center gap-3">
            <div className="flex items-center gap-2">
              <Label htmlFor="batch_reason" className="text-sm font-semibold">
                Reason *
              </Label>
              <Input
                id="batch_reason"
                value={batchReason}
                onChange={(e) => setBatchReason(e.target.value)}
                placeholder="Reason for this cycle count"
                className="w-64"
              />
            </div>
            <div className="text-sm text-muted-foreground">
              Selected: {selectedParts.length} • Valid: {validCount} • Invalid: {invalidCount}
            </div>
            {batchSummary && (
              <div className="text-sm text-muted-foreground">
                Updated {batchSummary.updated} • Skipped {batchSummary.skipped} • Failed {batchSummary.failed}
              </div>
            )}
          </div>
          <div className="rounded-md border border-border/60 bg-muted/50 p-3 text-sm">
            {cycleCountIssues.length > 0 ? (
              <ul className="list-disc list-inside space-y-1 text-destructive">
                {cycleCountIssues.map((issue) => (
                  <li key={issue}>{issue}</li>
                ))}
              </ul>
            ) : (
              <p className="text-muted-foreground">Ready to apply counts to {validCount} part(s).</p>
            )}
            <p className="text-[11px] text-muted-foreground">
              Tab/Shift+Tab moves • Enter next • ↑/↓ adjusts • ⌘/Ctrl+Enter applies • Esc blurs
            </p>
          </div>
          <div className="flex gap-2">
            <Button
              onClick={applyCounts}
              disabled={applyDisabled}
            >
              Apply Counts
            </Button>
            <Button
              variant="outline"
              onClick={() => {
                setCycleCountMode(false);
                setSelectedIds({});
                setCountInputs({});
                setBatchReason('');
                setBatchSummary(null);
              }}
            >
              Cancel
            </Button>
          </div>
        </div>
      )}

      <Dialog open={adjustDialogOpen} onOpenChange={(open) => { if (!open) closeAdjustDialog(); }}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Adjust QOH {selectedPart ? `(${selectedPart.part_number})` : ''}</DialogTitle>
          </DialogHeader>
          <div className="space-y-3">
            {adjustWarning && (
              <div className="text-sm text-amber-700 bg-amber-50 border border-amber-200 rounded-md px-3 py-2">
                {adjustWarning}
              </div>
            )}
            {adjustError && (
              <div className="text-sm text-destructive bg-destructive/10 border border-destructive/30 rounded-md px-3 py-2">
                {adjustError}
              </div>
            )}
            <div className="text-sm text-muted-foreground">
              Current QOH: <span className="font-medium text-foreground">{selectedPart?.quantity_on_hand ?? '—'}</span>
            </div>
            <div className="space-y-2">
              <Label htmlFor="new_qoh">New QOH</Label>
              <Input
                id="new_qoh"
                type="number"
                value={newQoh}
                onChange={(e) => setNewQoh(e.target.value)}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="adjust_reason">Reason *</Label>
              <Input
                id="adjust_reason"
                value={adjustReason}
                onChange={(e) => setAdjustReason(e.target.value)}
                placeholder="Why are you adjusting this quantity?"
              />
            </div>
            <div className="space-y-2">
              <p className="text-sm font-semibold">Recent History</p>
              <div className="grid gap-3 md:grid-cols-2 max-h-[320px] overflow-auto pr-1">
                <div className="border rounded-md">
                  <div className="px-3 py-2 text-xs font-semibold text-muted-foreground">Movements</div>
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead>Type</TableHead>
                        <TableHead className="text-right">Qty</TableHead>
                        <TableHead>By</TableHead>
                        <TableHead>Date</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {recentMovements.length === 0 ? (
                        <TableRow>
                          <TableCell colSpan={4} className="text-center text-muted-foreground text-sm">
                            No movements
                          </TableCell>
                        </TableRow>
                      ) : (
                        recentMovements.map((m) => (
                          <TableRow key={m.id}>
                            <TableCell className="uppercase text-xs font-semibold">{m.movement_type}</TableCell>
                            <TableCell className="text-right">{m.qty_delta}</TableCell>
                            <TableCell className="text-xs">{m.performed_by}</TableCell>
                            <TableCell className="text-xs whitespace-nowrap">
                              {new Date(m.performed_at).toLocaleString()}
                            </TableCell>
                          </TableRow>
                        ))
                      )}
                    </TableBody>
                  </Table>
                </div>
                <div className="border rounded-md">
                  <div className="px-3 py-2 text-xs font-semibold text-muted-foreground">Adjustments</div>
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead>Old/New</TableHead>
                        <TableHead className="text-right">Delta</TableHead>
                        <TableHead>By</TableHead>
                        <TableHead>Date</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {recentAdjustments.length === 0 ? (
                        <TableRow>
                          <TableCell colSpan={4} className="text-center text-muted-foreground text-sm">
                            No adjustments
                          </TableCell>
                        </TableRow>
                      ) : (
                        recentAdjustments.map((a) => (
                          <TableRow key={a.id}>
                            <TableCell className="text-xs">
                              {a.old_qty} → {a.new_qty}
                              {a.reason ? ` (${a.reason})` : ''}
                            </TableCell>
                            <TableCell className="text-right">{a.delta}</TableCell>
                            <TableCell className="text-xs">{a.adjusted_by}</TableCell>
                            <TableCell className="text-xs whitespace-nowrap">
                              {new Date(a.adjusted_at).toLocaleString()}
                            </TableCell>
                          </TableRow>
                        ))
                      )}
                    </TableBody>
                  </Table>
                </div>
              </div>
            </div>
          </div>
          <DialogFooter className="mt-4 flex flex-wrap items-start gap-3">
            {adjustIssues.length > 0 && (
              <div className="text-sm text-destructive mr-auto">
                <ul className="list-disc list-inside space-y-1">
                  {adjustIssues.map((issue) => (
                    <li key={issue}>{issue}</li>
                  ))}
                </ul>
              </div>
            )}
            <div className="flex gap-2">
              <Button variant="outline" onClick={closeAdjustDialog}>
                Cancel
              </Button>
              <Button onClick={handleSaveAdjustment} disabled={adjustIssues.length > 0}>
                Save
              </Button>
            </div>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}
